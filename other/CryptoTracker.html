<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Crypto Tracker</title>
    <style>
        /* --- Base and Typography --- */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #12121e;
    color: #f0f0f0;
    margin: 0;
    padding: 0;
}

header {
    text-align: center;
    padding: 30px 0 20px 0; 
    background-color: #1a1a2e;
    
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4); 
    border-bottom: 2px solid #4CAF50; 
}

h1 {
    margin: 0 0 5px 0; 
    font-size: 2.5em; 
    color: #4CAF50; 
    letter-spacing: 1.5px; 
    text-shadow: 0 0 5px rgba(76, 175, 80, 0.5); 
}

header p {
    font-size: 0.9em;
    color: #999;
    margin: 0;
}

main {
    width: 95%;
    max-width: 1400px;
    margin: 20px auto;
}

#global-stats {
    width: 90%;
    max-width: 1200px;
    margin: 30px auto; 
    display: flex;
    justify-content: space-around;
    gap: 15px;
    padding: 20px 15px;
    background-color: #1a1a2e;
    border-radius: 12px; 
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(76, 175, 80, 0.1); 
    border: 1px solid #333; 
}

.stat-card {
    text-align: center;
    padding: 5px 10px;
    flex: 1;
    border-right: 1px solid #333;
}

.stat-card:last-child {
    border-right: none;
}

.stat-card h3 {
    margin: 0 0 5px 0;
    font-size: 1.5em;
    color: #4CAF50; 
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.stat-card p {
    font-size: 2em; 
    font-weight: bold;
    color: #f0f0f0;
}

#controls {
    width: 90%;
    max-width: 1200px;
    margin: 10px auto;
    padding: 15px;
    background-color: #1a1a2e; 
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

#search-input {
    padding: 10px;
    border: 1px solid #4CAF50;
    border-radius: 5px;
    background-color: #1a1a1e;
    color: #f0f0f0;
    flex-grow: 1;
    max-width: 300px;
}

#filter-buttons {
    display: flex;
    gap: 10px;
}

#filter-buttons button, 
#sort-controls select,
#sort-controls label {
    padding: 8px 15px;
    border-radius: 5px;
    border: none;
    background-color: #2c2c47; 
    color: #f0f0f0;
    cursor: pointer;
    white-space: nowrap;
    transition: background-color 0.2s;
}
#filter-buttons button:hover {
    background-color: #3f3f61;
}


/* Style for the active/selected button */
.active-filter {
    border: 2px solid #00ff84 !important;
    background-color: #4CAF50 !important;
    color: #1a1a2e !important;
}

#sort-controls {
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
}

/* --- Crypto Table --- */
.crypto-table {
    width: 100%;
    border-collapse: collapse;
    background-color: #1a1a2e;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    margin-top: 20px;
}

.crypto-table th, .crypto-table td {
    padding: 15px;
    text-align: right;
    border-bottom: 1px solid #333;
}

.crypto-table th {
    background-color: #2c2c47;
    text-align: left;
    font-weight: bold;
    text-transform: uppercase;
    font-size: 0.85em;
    color: #4CAF50;
}

.crypto-table td:nth-child(1), .crypto-table th:nth-child(1) { text-align: center; width: 5%; }
.crypto-table td:nth-child(2), .crypto-table th:nth-child(2) { text-align: left; width: 18%; }
.crypto-table td:nth-child(7), .crypto-table th:nth-child(7) { width: 10%; }


.coin-name {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: normal;
}

.coin-logo {
    width: 24px;
    height: 24px;
}

/* Price change colors */
.price-up { color: #00ff84; }
.price-down { color: #ff5757; }

/* --- Price Flash Animation --- */
@keyframes flash-green {
  0% { background-color: #00ff8440;}
  100% { background-color: transparent;}
}

@keyframes flash-red {
  0% { background-color: #ff575740;}
  100% { background-color: transparent;}
}

.flash-green { animation: flash-green 1s ease-out;}
.flash-red { animation: flash-red 1s ease-out;}

/* --- Sparkline Chart --- */
.sparkline-chart {
  height: 30px;
  width: 100%;
}

.sparkline-chart svg {
  width: 100%;
  height: 100%;
}

footer {
  text-align: center;
  padding: 10px;
  color: #888;
  font-size: 0.8em;
  margin-top: 20px;
}


/* --- Responsive Adjustments --- */
@media (max-width: 1024px) {
  .crypto-table th:nth-child(4), .crypto-table td:nth-child(4) {
    display: none; } 
    #global-stats { flex-wrap: wrap;} 
    .stat-card { flex-basis: 45%; border-right: none;} 
    .stat-card:nth-child(odd) { border-right: 1px solid #333;}
}

@media (max-width: 768px) {
    #controls { flex-direction: column; align-items: stretch; }
    #search-input, #sort-controls { width: 100%; max-width: none; }
    #filter-buttons { justify-content: space-between; }
    #filter-buttons button { flex-grow: 1; }
    #sort-controls { justify-content: space-between; }
    .crypto-table th:nth-child(6), .crypto-table td:nth-child(6) { display: none; } 
}

@media (max-width: 500px) {
    .crypto-table th:nth-child(7), .crypto-table td:nth-child(7) { display: none; } 
}

    </style>
</head>
<body>
    <header>
        <h1>Cryptocurrency Live Price Tracker ðŸª™</h1>
        <p>Top 25 coins by market capitalization. Data updates automatically every 60s.</p>
    </header>
    
    <section id="global-stats">
        <div class="stat-card">
            <h3>Total Market Cap:</h3>
            <p id="total-market-cap">Loading...</p>
        </div>
        <div class="stat-card">
            <h3>BTC Dominance:</h3>
            <p id="btc-dominance">Loading...</p>
        </div>
        <div class="stat-card">
            <h3>24h Total Volume:</h3>
            <p id="total-volume">Loading...</p>
        </div>
    </section>
    
    <section id="controls">
        <input type="text" id="search-input" placeholder="Search by coin name or symbol...">
        
        <div id="filter-buttons">
            <button id="show-all-btn" data-filter="all" class="active-filter">Show All</button>
            <button data-filter="high_cap">High Cap ($1B+)</button>
            <button data-filter="low_price">Low Price (< $1)</button>
        </div>
        
        <div id="sort-controls">
            <label for="currency-select">Currency:</label>
            <select id="currency-select">
                <option value="usd">USD</option> 
                <option value="eur">EUR</option>
                <option value="gbp">GBP</option>
            </select>
            
            <label for="sort-select">Sort By:</label>
            <select id="sort-select">
                <option value="market_cap_rank_asc">Rank (Popularity)</option>
                <option value="current_price_desc">Price (High to Low)</option>
                <option value="market_cap_desc">Market Cap (High to Low)</option>
                <option value="total_volume_desc">24h Volume (High to Low)</option>
                <option value="price_change_percentage_7d_in_currency_desc">7d Change (High to Low)</option>
            </select>
        </div>
    </section>
    
    <main>
        <div id="crypto-container">
            <p id="loading-message">Loading top 25 cryptocurrency data...</p>
        </div>
    </main>
    
    <footer>
        <p>Data powered by CoinGecko API</p>
        <p id="last-updated"></p>
    </footer>
    
    <script>
        const CONFIG = {
            BASE_URL: 'https://api.coingecko.com/api/v3/',
            COINS_MARKETS_ENDPOINT: 'coins/markets',
            GLOBAL_ENDPOINT: 'global',
            REFRESH_RATE: 60000, 
            CACHE_KEY: 'cryptoTrackerData',
            API_PARAMS: `order=market_cap_desc&per_page=25&page=1&sparkline=true&price_change_percentage=1h%2C24h%2C7d`
        };

        const DOM = {
            container: document.getElementById('crypto-container'),
            lastUpdated: document.getElementById('last-updated'),
            searchInput: document.getElementById('search-input'),
            sortSelect: document.getElementById('sort-select'),
            currencySelect: document.getElementById('currency-select'),
            filterButtons: document.querySelectorAll('#filter-buttons button'),
            globalStats: {
                marketCap: document.getElementById('total-market-cap'),
                btcDominance: document.getElementById('btc-dominance'),
                totalVolume: document.getElementById('total-volume')
            }
        };

        let state = {
            cryptoData: [],         
            currentFilter: 'all',   
            currentCurrency: DOM.currencySelect.value, 
            oldPrices: {}           
        };

        function formatCurrency(number, currency = state.currentCurrency) {
            if (number === null || isNaN(number)) return ` -`;
            
            if (number >= 1e6 && currency === 'usd') { 
                const magnitude = Math.floor(Math.log10(number) / 3);
                const suffix = ['', 'K', 'M', 'B', 'T'][magnitude];
                const abbreviated = (number / Math.pow(1000, magnitude)).toFixed(2);
                
                const symbol = Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(0).charAt(0);
                return `${symbol} ${abbreviated}${suffix}`;
            }

            return number.toLocaleString('en-US', {
                style: 'currency',
                currency: currency.toUpperCase(),
                minimumFractionDigits: 2,
                maximumFractionDigits: number < 1 ? 6 : 2
            });
        }

        function formatPercentage(number) {
            if (number === null || isNaN(number)) return '-';
            const sign = number >= 0 ? '+' : '';
            const className = number >= 0 ? 'price-up' : 'price-down';
            return `<span class="${className}">${sign}${number.toFixed(2)}%</span>`;
        }

        function createSparkline(prices) {
            if (!prices || prices.length < 2) return '';

            const width = 100;
            const height = 30;
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const range = maxPrice - minPrice;
            const points = prices.length;
            
            const startPrice = prices[0];
            const endPrice = prices[prices.length - 1];
            const color = endPrice >= startPrice ? '#00ff84' : '#ff5757';

            const pointsArray = prices.map((price, index) => {
                const x = (index / (points - 1)) * width;
                let y = range === 0 ? height / 2 : height - ((price - minPrice) / range) * height;

                return `${x},${y}`;
            }).join(' ');

            return `
                <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none" class="sparkline-chart">
                    <polyline fill="none" stroke="${color}" stroke-width="1.5" points="${pointsArray}" />
                </svg>
            `;
        }

        function getFilteredAndSortedData() {
            let data = [...state.cryptoData];
            
            const MARKET_CAP_THRESHOLD = 1000000000;
            const PRICE_THRESHOLD = 1;

            switch (state.currentFilter) {
                case 'high_cap':
                    data = data.filter(coin => coin.market_cap >= MARKET_CAP_THRESHOLD);
                    break;
                case 'low_price':
                    data = data.filter(coin => coin.current_price < PRICE_THRESHOLD);
                    break;
            }

            const searchTerm = DOM.searchInput.value.toLowerCase().trim();
            if (searchTerm) {
                data = data.filter(coin => 
                    coin.name.toLowerCase().includes(searchTerm) || 
                    coin.symbol.toLowerCase().includes(searchTerm)
                );
            }

            const sortValue = DOM.sortSelect.value;
            const [key, order] = sortValue.split('_');

            data.sort((a, b) => {
                let valA = a[key];
                let valB = b[key];

                if (typeof valA === 'string') {
                    return order === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                
                const numA = valA ?? (order === 'asc' ? Infinity : -Infinity);
                const numB = valB ?? (order === 'asc' ? Infinity : -Infinity);
                
                return order === 'asc' ? numA - numB : numB - numA;
            });

            return data;
        }

        function renderCryptoTable() {
            const processedData = getFilteredAndSortedData();

            if (!processedData || processedData.length === 0) {
                DOM.container.innerHTML = '<p class="error-message">No results found matching your criteria.</p>';
                return;
            }

            const rows = processedData.map(coin => {
                const priceId = `price-${coin.id}`;
                const oldPrice = state.oldPrices[coin.id] || coin.current_price;
                const newPrice = coin.current_price;
                let flashClass = '';

                if (newPrice > oldPrice) {
                    flashClass = 'flash-green';
                } else if (newPrice < oldPrice) {
                    flashClass = 'flash-red';
                }

                state.oldPrices[coin.id] = newPrice;

                return `
                    <tr>
                        <td>${coin.market_cap_rank || '-'}</td>
                        <td>
                            <div class="coin-name">
                                <img src="${coin.image}" alt="${coin.name} logo" class="coin-logo">
                                <strong>${coin.name}</strong> (${coin.symbol.toUpperCase()})
                            </div>
                        </td>
                        <td id="${priceId}" class="${flashClass}">
                            ${formatCurrency(coin.current_price)}
                        </td>
                        <td>${formatPercentage(coin.price_change_percentage_1h_in_currency)}</td>
                        <td>${formatPercentage(coin.price_change_percentage_24h_in_currency)}</td>
                        <td>${formatPercentage(coin.price_change_percentage_7d_in_currency)}</td>
                        <td>${createSparkline(coin.sparkline_in_7d.price)}</td>
                        <td>${formatCurrency(coin.market_cap)}</td>
                        <td>${formatCurrency(coin.total_volume)}</td>
                    </tr>
                `;
            }).join('');

            const tableHTML = `
                <table class="crypto-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Coin</th>
                            <th>Price</th>
                            <th>1h Change</th>
                            <th>24h Change</th>
                            <th>7d Change</th>
                            <th>7d Trend</th>
                            <th>Market Cap</th>
                            <th>24h Volume</th>
                        </tr>
                    </thead>
                    <tbody>${rows}</tbody>
                </table>
            `;

            DOM.container.innerHTML = tableHTML;
            
            processedData.forEach(coin => {
                const priceCell = document.getElementById(`price-${coin.id}`);
                if (priceCell) {
                    setTimeout(() => priceCell.classList.remove('flash-green', 'flash-red'), 1000);
                }
            });
        }

        async function updateGlobalStats() {
            try {
                const response = await fetch(CONFIG.BASE_URL + CONFIG.GLOBAL_ENDPOINT);
                if (!response.ok) throw new Error(`Global API error! status: ${response.status}`);
                
                const globalData = await response.json();
                const marketData = globalData.data;
                
                const totalMarketCap = marketData.total_market_cap[state.currentCurrency] || marketData.total_market_cap.usd;
                const totalVolume = marketData.total_volume[state.currentCurrency] || marketData.total_volume.usd;

                DOM.globalStats.marketCap.textContent = formatCurrency(totalMarketCap, 'usd'); 
                DOM.globalStats.btcDominance.textContent = `${marketData.market_cap_percentage.btc.toFixed(2)}%`;
                DOM.globalStats.totalVolume.textContent = formatCurrency(totalVolume, 'usd');
            } catch (error) {
                console.error("Error fetching global stats:", error);
                DOM.globalStats.marketCap.textContent = 'N/A';
                DOM.globalStats.btcDominance.textContent = 'N/A';
                DOM.globalStats.totalVolume.textContent = 'N/A';
            }
        }

        function loadFromCache() {
            const cached = localStorage.getItem(CONFIG.CACHE_KEY);
            if (cached) {
                const cacheData = JSON.parse(cached);
                const cacheAge = Date.now() - cacheData.timestamp;

                if (cacheAge < 300000) { 
                    state.cryptoData = cacheData.data;
                    renderCryptoTable();
                    DOM.lastUpdated.textContent = `Last updated: (Cached) ${new Date(cacheData.timestamp).toLocaleTimeString()}`;
                    return true;
                }
            }
            return false;
        }

        async function fetchCryptoData() {
            DOM.container.innerHTML = '<p id="loading-message">Fetching the latest prices...</p>';
            DOM.lastUpdated.textContent = 'Last updated: Fetching...';
            
            if (!loadFromCache()) {
                console.log("No valid cache found. Fetching live data...");
            }

            const marketURL = `${CONFIG.BASE_URL}${CONFIG.COINS_MARKETS_ENDPOINT}?vs_currency=${state.currentCurrency}&${CONFIG.API_PARAMS}`;

            try {
                const response = await fetch(marketURL);
                
                if (!response.ok) {
                    if (response.status === 429) {
                        throw new Error("API Rate Limit Exceeded. Please wait 60 seconds before refreshing.");
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const freshData = await response.json(); 
                state.cryptoData = freshData;
                
                const cacheData = { data: freshData, timestamp: Date.now() };
                localStorage.setItem(CONFIG.CACHE_KEY, JSON.stringify(cacheData));
                
                renderCryptoTable();
                updateGlobalStats(); 
                
                const now = new Date();
                DOM.lastUpdated.textContent = `Last updated: ${now.toLocaleTimeString()}`;

            } catch (error) {
                console.error("Error fetching crypto prices:", error);
                
                if (state.cryptoData.length === 0) {
                    DOM.container.innerHTML = `<p class="error-message">Failed to load data. ${error.message}. Please try again later.</p>`;
                    DOM.lastUpdated.textContent = 'Last updated: Failed.';
                }
            }
        }

        function handleFilterClick(event) {
            const button = event.target.closest('button');
            if (!button) return;

            state.currentFilter = button.dataset.filter || 'all'; 
            
            DOM.filterButtons.forEach(btn => btn.classList.remove('active-filter'));
            button.classList.add('active-filter');

            renderCryptoTable();
        }

        function handleCurrencyChange() {
            state.currentCurrency = DOM.currencySelect.value;
            fetchCryptoData(); 
        }

        function init() {
            DOM.searchInput.addEventListener('input', renderCryptoTable);
            DOM.sortSelect.addEventListener('change', renderCryptoTable);
            DOM.currencySelect.addEventListener('change', handleCurrencyChange);
            DOM.filterButtons.forEach(button => {
                button.addEventListener('click', handleFilterClick);
            });

            fetchCryptoData();

            setInterval(fetchCryptoData, CONFIG.REFRESH_RATE);
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
